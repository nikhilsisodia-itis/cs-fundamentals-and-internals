# Memory Management Internals

## 1. What is memory?

- Memory (RAM) is where data and instructions are temporarily stored for quick access by the CPU.
- It is volatile, meaning it loses its contents when the power is turned off.
- It is faster than other types of storage like hard drives or SSDs.

## 2. What is memory management?

- Memory management is the process of controlling and coordinating computer memory, including allocating and deallocating memory spaces as needed by programs.
- It ensures that each process has enough memory to execute while optimizing overall system performance.

## 3. Need of Memory Management

- As multiple programs share one physical memory, the OS must:
  - Keep each program’s data safe (isolation).
  - Use memory efficiently.
  - Handle cases when memory runs out.
  - Provide fast access to frequently used data.
- That’s what Memory Management does — it allocates, tracks, and reclaims memory safely.

## 4. Types of Memory

| Type | Description | Example |
| - | - | - |
| **Primary Memory** | Fast, volatile (loses data on shutdown). | RAM |
| **Secondary Memory** | Slower, non-volatile. | SSD, HDD |
| **Cache Memory** | Very fast memory inside CPU. | L1, L2, L3 cache |
| **Virtual Memory** | OS-managed “illusion” of larger memory. | Swap area on disk |

## 5. Key Terminology

| Term | Meaning |
| - | - |
| **Address** | A location in memory (like a house number). |
| **Physical Address** | Actual location in RAM hardware. |
| **Virtual Address**  | “Fake” address given to each process by the OS. |
| **Page** | Fixed-size block of memory (commonly 4 KB). |
| **Frame** | Physical memory block that holds a page. |
| **Swap Space** | Part of disk used as virtual memory. |
| **Segmentation** | Division of memory into logical segments (code, stack, heap) |
| **Paging** | Dividing memory into fixed-size pages for easier management. |
| **Fragmentation** | Wasted memory space due to allocation/deallocation. |
| **Thrashing** | Excessive paging causing slow performance. |

## 6. Virtual Memory

- Virtual Memory lets every process think it has its own large, continuous block of memory- but in reality, those blocks are mapped to different places in physical RAM.
- This gives:
  - Isolation (processes can’t see each other’s memory).
  - Efficiency (unused parts can be swapped out).
  - Security (no direct hardware access).

## 7. Paging – How Virtual Memory Works Internally

- Virtual memory is divided into pages, typically 4 KB in size.
- Each page maps to a frame in physical memory.
| Concept | Description |
| - | - |
| **Page Table** | A data structure that maps virtual pages → physical frames. |
| **Page Fault** | Happens when the requested page isn’t in RAM (fetched from disk). |

## 8. Swapping — Extending Memory onto Disk

- When RAM is full, inactive pages are moved to swap on disk.
- It prevents crashes.
- But it is much slower than RAM (10–100× slower).
- Excessive swapping leads to thrashing, where the system spends more time swapping than executing.
- How to control swap:
  - `sudo swapon /path/to/swapfile` to enable swap.
  - `sudo swapoff /path/to/swapfile` to disable swap.

## 9. How All This Fits Together

- Data Flow Example: User Open Firefox
  - User run firefox → process created.
  - Kernel allocates virtual memory pages.
  - Pages are mapped to physical RAM frames.
  - When new tabs open, heap expands (dynamic allocation).
  - If user run out of RAM → inactive pages are swapped to disk.
  - When user close Firefox → kernel frees all its pages back to the system.
