# Process Internals and Switching

## 1. Introduction to Processes

### 1.1. What is a process?

- A process is a running instance of a program.
- It’s the OS’s way of tracking and managing all active programs.
- Example:
  - The Firefox application file on disk → /usr/bin/firefox
  - When user opens it, OS loads it into memory → creates a process.
- That process has:
  - Its own memory area.
  - Unique ID (PID).
  - Registers, program counter, and stack.
  - Permissions and owner.
  - Parent process.

### 1.2. Program VS Process

| Program | Process |
| - | - |
| Static file stored on disk. | Running instance in memory. |
| Passive (does nothing until run) | Active (uses CPU, memory, etc.) |
| Example: `/usr/bin/vim` | Example: `PID 1472 running vim` |

## 2. Process Lifecycle

### 2.1. Process lifecycle overview

- A process goes through multiple stages:

```bash
+-----+       +-------+       +---------+       +------------+
| New | --->  | Ready | --->  | Running | --->  | Terminated |
+-----+       +-------+       +---------+       +------------+
                  ↑                ↓
                  |                |
            +---------+       +---------+
            | Waiting | <---- | Blocked |
            +---------+       +---------+
```

### 2.2. Process States explaination

| State | Meaning |
| - | - |
| **New** | Being created (not yet running) |
| **Ready** | Waiting for CPU time |
| **Running** | Currently executing on CPU |
| **Waiting/Blocked** | Waiting for I/O (e.g., reading from disk) |
| **Terminated/Zombie** | Finished but waiting for parent to acknowledge it |

### 2.3. Process hierarchy

- Every process is started by another process (except init or systemd, PID 1).
- `pstree` command is used to display the hierarchy of different processes.
- `systemd` is the root parent process.
- Every child inherits environment, permissions, and sometimes file descriptors from its parent.

## 3. How a process is created?

- In Linux, creating a process happens in 2 steps:
  - fork() → duplicates the current process.
  - exec() → replaces the child’s memory with a new program.

## 4. Types of Processes

| Type | Description | Example |
| - | - | - |
| **Foreground** | Takes user input directly. | `vim`, `cat`, `ls` |
| **Background** | Runs silently in the background. | `updatedb`, `cron` |
| **Daemon** | Always running, started at boot. | `sshd`, `systemd`, `NetworkManager` |

## 5. Zombie & Orphan Processes

| Type | Description | Why it Happens |
| - | - | - |
| **Zombie** | Process finished but parent didn’t read its exit status. | Poor cleanup. |
| **Orphan** | Parent process died first; child adopted by `init`. | Crash of parent. |

## 6. Context Switching

### 6.1. What is Context Switching?

- Context switching is when CPU switches from one process to another.
- Since CPUs can only run one task per core at a time, the OS rapidly switches between them — giving the illusion of multitasking.
- Each switch involves:
  - Saving current process state (registers, PC, stack).
  - Loading next process state.
- This happens thousands of times per second.

## 7. CPU Scheduling

### 7.1 What is CPU Scheduling?

- CPU Scheduling is the process of deciding which process to run and in which manner.
- The OS uses scheduling algorithms to decide: Which process to run next?
- Goals:
  - Maximize CPU use.
  - Minimize waiting time.
  - Ensure fairness.

### 7.2 Common Scheduling Algorithms

| Algorithm | Description | Example Use |
| - | - | - |
| **FCFS (First Come, First Serve)** | Runs in order of arrival. | Simple and fair, but not efficient. |
| **SJF (Shortest Job First)** | Runs shortest process first. | Batch systems. |
| **Round Robin (RR)** | Each process gets a fixed CPU time slice. | Interactive systems. |
| **Priority Scheduling** | Runs highest-priority process first. | Real-time or kernel tasks. |
| **Multilevel Queue** | Different queues for different types of jobs. | Linux kernel uses a variant. |
